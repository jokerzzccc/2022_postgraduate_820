# 目录

[toc]

# 数据结构

时间：2021-10

目的：考研（820）

作者：joker

# 一、数据结构基本概念

1. 数据结构的**三要素**：逻辑结构、存储结构、数据的运算。

2. 算法的**5个重要特性**：有穷性、确定性、可行性、输入、输出。

3. **好的算法的目标**：正确性、可读性、健壮性、效率与低存储量需求。

4. 算法的**时间复杂度**：

   1. 一个语句的频度：是指该语句在算法中被重复执行的次数；算法中所有语句的频度之和记为 $T(n)$

   2. 时间复杂度：主要分析，$T(n)$ 的数量级。**算法中基本运算（最深层循环内的语句）**的频度与 $T(n)$同数量级。因此**采用算法中基本运算的频度 $f(n)$ **来分析时间复杂度。记为 $T(n) = O(f(n))$ .

   3. 分析程序的时间复杂度的规则：

      1. **加法规则**：$T(n) = T_1(n) + T_2(n) = O(f(n)) + O(g(n)) = O(\max({f(n),g(n)}))$ 
      2. **乘法规则**：$T(n) = T_1(n)*T_2(n)=O(f(n)*g(n))$ 

   4. 常见的时间复杂度：

      $O(1)<O(\log_2n)<O(n)<O(n\log_2n)<O(n^2)<O(2^n)<O(n!)<O(n^n)$ 

5. 算法的**空间复杂度**：该算法所耗费的存储空间，

   1. 算法**原地工作**：之算法所需的辅助空间为常量，即$O(1)$ 

6. 

# 二、线性表

## 2.1 线性表的定义和基本操作

1. 线性表的**定义**：是具有相同数据类型的 n (n >= 0) 个数据元素的有限序列。
2. 线性表的**特点**：
   1. 表中元素的**个数有限**。
   2. 表中元素具**有逻辑上的顺序性**，表中元素尤其先后次序。
   3. 表中元素都是数据元素，每个元素都是单个元素。
   4. 表中元素的数据类型都相同。
   5. 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。
3. 注意：
   1. **线性表**是一种**逻辑结构**，表示元素间一对一的相邻关系。
   2. **顺序表和链表**是指**存储结构**。



## 2.2 线性表的顺序表示

1. 顺序表的**定义**：线性表的顺序存储。
2. 顺序表的**特点**：
   1. 逻辑顺序与物理顺序相同。
   2. 优点：**随机访问**。可通过首地址和元素序号可在时间$O(1)$内找到指定的元素。
   3. 缺点：插入和删除操作需要移动大量元素。
3. 顺序表的**基本操作 **
   1. 插入操作
      1. 时间复杂度：
         1. 最好情况： O(1)
         2. 最坏情况：O(n)
         3. 平均情况：移动结点的平均次数为 $\frac{n}{2}$，所以平均 时间复杂度为O(n)
   2. 删除操作
      1. 时间复杂度：
         1. 最好情况： O(1)
         2. 最坏情况：O(n)
         3. 平均情况：移动结点的平均次数为 $\frac{n-1}{2}$，所以平均时间复杂度为O(n)
   3. 按值查找（顺序查找）
      1. 时间复杂度：
         1. 最好情况： O(1)
         2. 最坏情况：O(n)
         3. 平均情况：移动结点的平均次数为 $\frac{n+1}{2}$，所以平均时间复杂度为O(n)

## 2.3 线性表的链式表示

### 2.3.1 单链表的定义

1. 单链表的定义：线性表的链式存储。

   1. 指通过**一组任意的存储单元**来存储线性表中的数据元素。

2. 单链表的**结点类型**描述如下：

   ```c
   // 单链表-结点类型
   typedef struct LNode{
       ElemType data;
       struct LNode *next;
   }LNode, *LinkList;
   ```

3. 单链表的特点：

   1. **缺点**：
      1. **非随机存取**
      2. 查找某个特定的结点时，需要**从表头开始遍历**。
   2. **优点**：
      1. 可以解决顺序表需要大量连续存储单元的缺点。

4. 注意：

   1. 通常用**头指针（L）**来标识一个单链表；
   2. **头结点**：在单链表第一个结点之前附加一个结点。
      1. 头结点的数据域：可以不设任何信息，也可以记录表长等信息。
      2. 头结点的指针域：指向线性表的第一个元素。
   3. **头结点和头指针的区别**：
      1. 不管带不带头结点，头指针始终指向链表的第一个表结点；
      2. 而头结点时带头结点的链表的第一个结点，结点内通常不含信息。
   4. 引入**头结点**后的**优点**：
      1. 在链表的第一个位置上的操作与表的其它位置上的操作一致，无需特殊处理。
      2. 无论链表是否为空，其头指针都指向头结点的非空指针，因此**空表和非空表的处理得到了统一**。

### 2.3.2 单链表上基本操作的实现

1. 采用**头插法**建立单链表：

2. 采用**尾插法**建立单链表：

   1. 需要一个表尾指针 *r 。

3. **按序号查找**结点值

4. **按值查找**表结点

5. **插入结点**操作：

   1. **后插**操作：

      ```c
      	// 单链表-后插操作
      	p = GetElem(L,i-1); // 查找插入位置的前驱结点
          s->next = p->next;
      	p->next = s;
      ```

      

   2. **前插**操作：

      ```c
      	// 单链表-前插操作
      	s->next = p->next; // 修改指针域，不能颠倒
      	p->next = s;
      	temp = p->data;	// 交换数据
      	p->data = s->data;
      	s->data = temp;
      ```

      

6. **删除结点**操作：

   1. 删除第 i 个结点：

      ```c
      // 单链表-删除结点-删除第 i 个结点
      p = GetElem(L,i-1);
      q = p->next;
      p->next = q->next;
      free(q);
      ```

   2. 删除节点 *p

      ```c
      // 单链表-删除结点-删除结点 *p
      q = p->next;
      p->data = p->next->data;
      p->next = q->next;
      free(q);
      ```

7. **求表长**操作：

   1. 时间复杂度：$O(n)$ 



### 2.3.3 双链表

1. 双链表的定义：

   1. 双链表的**结点类型**的描述如下：

      ```c
      // 双链表的结点类型
      typedef struct DNode{
          ElemType data; // 数据域
          struct DNode *prior,*next; // 前驱和后继指针
      }DNode, *Dlinklist;
      ```

2. 双链表的**插入**操作：

   1. 在双链表中 P 所指结点之后插入结点 *s。

      ```c
      // 双链表-插入
      s->next = p->next;
      p->next-prior = s;
      s->prior = p;
      p->next = s;
      ```

   2. 注意：上面的语句顺序不是唯一的，但是第1，2步必须在第4步之前。

3. 双链表的**删除**操作：

   1. 删除双链表中结点 *p 的后继结点 *q

      ```c
      p->next = q->next;
      q->next->prior = p;
      free(q);
      ```

      



### 2.3.4 循环链表

1. **循环单链表**
   1. 循环单链表与单链表的**区别**在于：表中最后一个结点的指针不是 NULL ，而改为指向头结点，从而整个链表形成一个环。
   2. 循环单链表的**判空条件**：不是头结点的指针是否为空，而是**头结点的指针是否等于头指针**。
2. **循环双链表**
   1. 循环双链表：头结点的 prior 指针还要指向表尾结点。
   2. 循环双链表的**判空条件**：其头结点的 prior 域和 next 域都等于 L (头指针)。



### 2.3.5 静态链表

1. 静态链表借助**数组**来描述线性表的链式存储结构。
   1. 结点也有数据域 data 和指针域 next ，不过，这里的指针式结点的相对地址（数组下标），又称游标。
   2. 静态链表也要预先分配一块连续的内存空间。
   3. 以 next == -1 为结束的标志。即尾结点。



# 三、栈、队列、数组

## 3.1 栈

1. 栈的**相关概念**：
   1. 栈（Stack）的**定义**：只允许在一端进行插入和删除的线性表。
   2. **栈顶（Top)**：线性表允许插入和删除的一端。
   3. **栈底（Bottom）**：固定的，不允许进行插入和删除的一端。
   4. **空栈**：不含任何元素的空表。
   5. 栈的数学性质：n 个不同元素进栈，**出栈**的**不同排列**的个数为 $\frac{1}{n+1} C_{2n}^{n}$
2. 栈的**基本操作**：
3. 栈的**顺序存储结构**： 
4. 栈的**链式存储结构**：
   1. 

## 3.2 队列

### 3.2.1 队列的基本概念

1. 队列的定义：一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。
2. 入队（进队）：向队列中插入元素；
3. 出队（离队）：删除元素。
4. 操作特性：先进先出
5. 队头（Front）：允许删除的一端，也称队首。
6. 队尾（Rear）：允许插入的一端。
7. 队列的**基本操作**：



### 3.2.2 队列的**顺序存储结构**：

1. **队列的顺序存储**
   1. 队列的顺序存储的**定义**：分配**一块连续的的存储单元**存放队列元素，并附两个指针：队头指针 Front 指向队头元素，队尾指针 rear 指向队尾元素的**下一个位置**。
   2. 注意：不同教材的 front 和 rear 的定义可能不同。比如：rear 可能指向队尾元素。（根据题意决定）。
   3. **初始状态（队空条件）**：$Q.front == Q.rear==0$ 
   4. **进队操作**：队不满时，先送值到队尾元素，再将队尾指针 rear + 1
   5. **出队操作**：队不空时，先取队头元素，再将队头指针 front + 1
2. **循环队列**
   1. 循环队列的**定义**：把存储队列元素的表从**逻辑上**视为一个**环**，称为循环队列。
   2. 初始时：$Q.front =Q.rear=0$
   3. 队首指针进1：$Q.front=(Q.front+1) \% MaxSize$ 
   4. 队尾指针进1：$Q.rear=(Q.rear+1) \% MaxSize$
   5. 队列长度：$(Q.rear+Maxsize-Q.front)\%Maxsize$
   6. 出队，入队时：指针都按顺时针方向进1.
   7. 循环队列：
      1. **判队空**：$Q.front==Q.rear$
      2. 队满时，仍有 $Q.front==Q.rear$
   8. 为了区分队空还是队满，有三种处理方式，主要是**第一种**：
      1. 法一：牺牲一个单元来 区分队空还是队满，入队时少用一个队列单元。
         1. 判队满：队头指针在队尾指针的下一位置作为队满的标志。
         2. **队满**条件：$(Q.rear+1) \% Maxsize == Q.front$
         3. **队空**条件：$Q.front==Q.rear$
         4. 队列中元素的个数：$(Q.rear+Maxsize-Q.front)\%Maxsize$
      2. 法二：类型中增设表示元素个数的数据成员。
      3. 法三：类型中增设 tag 数据成员，以区分是队满还是队空。
         1. tag 为 0：因删除导致$Q.front==Q.rear$，则为队空。
         2. tag 为 1：因插入导致$Q.front==Q.rear$，则为队满。



### 3.2.3 队列的链式存储结构

1. 队列的**链式存储**



### 3.2.4 双端队列

1. 双端队列：两端都可以入队和出队操作的队列，队列的两端分为前端和后端。
   1. 
2. 输出受限的双端队列：
3. 输入受限的双端队列：

## 3.3 栈和队列的应用

1. **栈**的应用：
   1. 栈在**括号匹配**的应用：
   2. 栈在**表达式求值**的应用：
   3. 栈在**递归**中的应用：
   4. **中缀表达式**转换为**后缀表达式**的算法思想：（王道 $P_{93}$）
      1. 从左向右开始扫描中缀表达式；
      2. 遇到**数字**时，加入后缀表达式；
      3. 若遇到**预算符**：
         1. 若为 `（` 时，入栈；
         2. 若为 `）`时，则依次把栈中的运算符加入后缀表达式，直到出现 `（` ，并从栈中删除 `（`。
         3. 若为除括号外的其它运算符：
            1. 当其优先级高于除 `（` 的栈顶运算符时，直接入栈；
            2. 否则，从栈顶开始，一次弹出比当前处理的运算发优先级高和优先级相等的运算符，直到一个比它优先级低的 或 遇到了一个左括号  `（` 为止。
2. **队列**的应用：
   1. 队列在**层次遍历**中的应用：
   2. 队列在**计算机系统**中的应用：（有很多，主要从两方面）
      1. 一个方面：解决主机与外部设备之间速度不匹配的问题。
      2. 另一方面：解决由用户引起的资源竞争的问题。

## 3.4 数组

1. 数组的**定义**：
2. 数组的**存储结构**：一段连续的存储空间。
3. **矩阵的压缩存储**：
   1. **压缩存储**：为多个相同元素只分配一个存储空间；对零元素不分配存储空间。目的是，节省存储空间。
   2. 特殊矩阵：具有许多相同元素或零元素，并且这些元素的分布具有一定的规律性。
      1. 对称矩阵：
      2. 三角矩阵：
      3. 三对角矩阵：
4. **稀疏矩阵**：
   1. 定义：非零元素个数 **远小于** 矩阵元素个数 的矩阵 。
   2. 存储：将非零元素及其相应的行和列构成一个**三元组（行标，列标，值）**。既可采用数组存储，也可以采用十字链表法存储。

# 四、树与二叉树

## 4.1 树的基本概念

1. **树的性质**：
   1. 树中的结点数 等于 所有结点的度数之和加 1。
   2. 度为 m 的树中第 i 层上至多有 $(m^{i-1}$ 个结点。（i >= 1)
   3. 高度为 h 的 m 叉树至多有 $(m^h - 1)/(m-1)$ 个结点。
   4. 具有 n 个结点的 m 叉树的**最小高度**为 $\lceil \log_n(n(m-1)+1) \rceil$ 。
2. **重点**：==树节点与度之间的关系：==
   1. 总结点数 = $n_0 + n_1+n_2+...+n_m$
   2. 总分支数 =  $n_1 +2n_2+3n_3+...+mn_m$ (度为 m 的结点引出的 m 条分支)
   3. 总结点数 = 总分支数 + 1 
   4. 题型：$n_0 + n_1+n_2+...+n_m = n_1 +2n_2+3n_3+...+mn_m + 1$ 来求 $n_0$

## 4.2 二叉树

### 4.2.1 二叉树的定义及其主要特征

#### 1、**几种特殊二叉树**：

1. **满二叉树**：
   1. 定义：一棵高度为 h ，且含有 $2^h - 1$ 个结点的二叉树，称为满二叉树。
   2. 满二叉树按层序编号：对于编号为 i 的结点
      1. 若有双亲，则其双亲为 $\lfloor i/2 \rfloor$
      2. 若有左孩子，则左孩子为 $2i$
      3. 若有右孩子，则右孩子为 $2i+1$
2. **完全二叉树**：
   1. 定义：树中的编号与满二叉树的编号一一对应时。
   2. 性质：
      1. 最后一个分支结点 $\lfloor n/2 \rfloor$ 。
      2. 若 i <= $\lfloor n/2 \rfloor$ 则结点 i  为分支结点，否则为叶子节点。
      3. 叶子结点只可能出现在最后两层。
      4. 结点 i 所在深度（层次）为 $\lfloor log_2i \rfloor + 1$ 
      5. 具有 n 个结点的完全二叉树的高度 为 $\lceil \log_2(n+1) \rceil$  或 $\lfloor \log_2i \rfloor +1$ 
3. **二叉排序树**：
   1. 定义：左子树上所有结点的关键字都小于根结点的关键字；右子树所有结点的关键字都大于根结点的关键字。左右子树又分别为二叉排序树。
4. **平衡二叉树**：
   1. 定义：树上任一结点的左右子树高度之差不超过 1.

#### 2、**二叉树的性质**：

1. 非空二叉树的**叶子结点数**等于度为2的结点数加1：$n_0 = n_2 + 1$ 
2. 非空二叉树**第 k 层**至多有 $2^{k-1}$ 个结点。



### 4.2.2 二叉树的存储结构

1. **顺序存储结构**：

   1. 二叉树的顺序存储：是指用 一组地址连续的存储单元依次自上而下，自左至右存储完全二叉树上的节点元素。 
   2. 最坏情况下，一个**高度为 h **的且只有 h 个结点的单支树需要占据 **$2^h - 1$ 个存储单元**。

2. **链式存储结构**：

   1. 链表结点：
      1. 左指针域：
      2. 数据域：
      3. 右指针域：
   2. 性质：
      1. 在 n 个结点的二叉链表中，含有 n + 1 个空链域。

   

### 4.2.3 二叉树的遍历

- 常见的遍历：先序（NLR），中序（LNR），后序（LRN）。其中 “序”指根节点何时被访问。

1. **先序遍历**：
2. **中序遍历**：
3. **后序遍历**：
4. 递归算法与非递归算法的转换：
5. 层次遍历:
6. 由遍历序列构造而二叉树：



### 4.2.4 线索二叉树

1. 二叉树的线索化：是将二叉链表中的空指针改为**指向前驱或后继的的线索**。

2. **线索化的实质**：就是遍历一次二叉树。

3. 通过**中序遍历**对二叉树**线索化**的**递归**算法：

   ```c
   // 中序遍历对二叉树线索化的递归算法
   
   ```

4. 带有**头结点**的线索链表：

   1. 头结点：
      1. 左指针域指向二叉树的根结点；
      2. 右指针域指向中序访问时，的最后一个结点；
      3. 令中序序列的第一个结点的左指针域和最后一个结点的右指针域均指向头结点。
   2. 好处：方便从前往后或从后往前对线索二叉树进行遍历。

5. 中序线索二叉树的遍历：

6. 

## 4.3 树、森林

### 4.3.1 树的存储结构

1. **双亲表示法**：
2. **孩子表示法**：
3. **孩子兄弟表示法**：



### 4.3.2 森林与二叉树的转换

1. **树转化为二叉树**：
2. **森林转化为二叉树**：
3. **二叉树转化为森林**：



### 4.3.3 树和森林的遍历

1. **树**的遍历：
   1. **先根遍历**：
   2. **后根遍历**：
2. **森林**的遍历：
   1. 先序遍历森林：
   2. 后序遍历森林：



## 4.4 树与二叉树的应用

### 4.4.1 二叉排序树(BST)

1. 二叉排序树的**定义**：
   1. 左子树结点值 < 根结点值 < 右子树结点值。
   2. 性质：对二叉排序树进行中序遍历，可以得到一个**递增**的有序序列。
2. 二叉排序树的**查找**：
3. 二叉排序树的**插入**：
4. 二叉排序树的**构造**：
5. 二叉排序树的**删除**：
   1. 右子树为空，用左子女替代；
   2. 左子树为空，用右子女替代；
   3. 左、右子树均不空，则，在**右子树**上找**中序第一个子女**填补。
6. 二叉排序树的**查找效率分析**：
   1. 二叉排序树若为平衡二叉树，则，平均查找长度 为 $O(\log_2n)$。
   2. **最坏情况**：构造二叉排序树时的**输入序列有序**，则会形成一个单支树。平均查找长度为 $O(n)$



### 4.4.2 平衡二叉树（BBT)

1. 平衡二叉树的**定义**：
   1. 左右子树高度差的绝对值不超过 1，这样的二叉树成为平衡二叉树（Balanced Binary Tree）。
   2. **平衡因子**：结点左子树和右子树的高度差。只能是 -1、0、1.
2. 二叉排序树保证平衡的基本思想：
   1. 插入，如果导致了不平衡，则先找到插入路径上离插入结点**最近**的平衡因子绝对值大于1的结点 A 。
   2. 再以 A 为根的子树，进行调整。
3. 平衡二叉树的**插入造成的不平衡调整**：
   1. LL 平衡旋转：新结点插入在**左孩子的左子树上**。
   2. RR 平衡旋转：新结点插入在**右孩子的右子树上**。
   3. LR 平衡旋转：新结点插入在**左孩子的右子树上**。
   4. RL 平衡旋转：新结点插入在**右孩子的左子树上**。
4. 平衡二叉树的**查找**：
   1. 平衡二叉树的查找过程与二叉排序树相同。
   2. 查找过程中，进行**比较**的关键字**个数**不超过树的深度 。
   3. 含有 n 个结点的平衡二叉树**最大深度**为  $O(\log_2n)$ 。
   4. 平衡二叉树的**平均查找长度**：$O(\log_2n)$



### 4.4.3 哈夫曼树和哈夫曼编码

1. 哈夫曼树的**定义**：
   1. **结点的带权路径长度**：根结点到该结点的路径长度与该结点上权值的乘积。
   2. **树的带权路径长度(WPL)**：所有叶结点的带权路径长度之和。
      1. 记为：$WPL = \displaystyle\sum_{i=1}^{n} w_il_i$
      2. $w_i$ :第i个叶结点的权值，
      3. $l_i$：叶结点到根结点的路径长度。
   3. **哈夫曼树**（最优二叉树）：在含有 n 个带权叶结点的二叉树中，其中带权路径长度最小的二叉树。
2. 哈夫曼树的**构造**：
   1. 每次选取**两个权值最小**的结点作为新结点的左右子树。
3. 哈夫曼树的**特点**：
   1. 每个初始结点都将成为叶结点；且权值越小的结点到根结点的路径长度越大。
   2. 构造过程中，共新建了 n - 1 个新结点，因此，哈夫曼夫的**结点总数**是 $2n -1$ 
   3. 哈夫曼树中**不存在度为1**的结点。
   4. 因为左右孩子结点的顺序是随意的，所以构造出的哈夫曼树**不唯一**。但，各哈夫曼树的带权路径长度（WPL）相同且为最优。
4. **哈夫曼编码**：
   1. **前缀编码**：若没有一个编码是另一个编码的前缀。
   2. 0：转向**左**孩子。
   3. 1：转向**右**孩子。





# 五、图

## 5.1 图的基本概念

1. **图的定义**：图 G 由顶点集 V 和边集 E 组成，记为 $G = (V,E)$ ，
   1. V(G)：表示图 G 中顶点的有限非空集；
   2. E(G)：表示图 G 中顶点之间的关系（边）的集合。
   3. |V|：表示图 G 中顶点的个数。
   4. |E|：表示图 G 中边的条数。
   5. 注意：
      1. 线性表可是空表，树可以是空树，但**图不可以是空图**。
      2. 图的顶点集一定是非空，但边集可以为空。
2. 有向图：
3. 无向图：
4. 简单图：满足以下两点的图（数据结构中只讨论简单图）
   1. 不存在重复的边；
   2. 不存在顶点到自身的边。
5. 多重图：
6. **完全图**（简单完全图）：
   1. 对于无向图：|E| 的取值范围为0到 n(n-1)/2，**有 $n(n-1)/2$ 条边的无向图**称为完全图。
   2. 对于有向图：有 n(n-1) 条弧的有向图，称为有向完全图。
7. **子图**：
   1. 子图 G‘ ：设有两个图 G = (V,E) 和 G’ = (V',E') ，若 V' 是 V 的子集，且 E' 是 E 的子集，则称 G' 是 G 的子图。
   2. **生成子图**：若有满足V(G') = V(G)，则称其为 G 的生成子图。
   3. 注意：并非 V 和 E 的任何子集都能构成 G 的子图。
8. 连通的：无向图中，若从顶点 v 到顶点 w 有路径存在，则称 v 和 w 时连通的。
9. **连通图**：若无向图 G 中任意两个顶点都是连通的，则称图 G 为连通图，否则为非连通图。
10. 连通分量：无向图中的极大连通子图称为连通分量。
    1. 注意：在**无向图**中讨论**连通性**；在**有向图**中讨论**强连通性**。
11. 强连通的：
12. 强联通图：
13. 强联通分量：
14. **生成树**：
    1. 连通图的生成树：时包含图中全部顶点的一个极小连通子图。
       1. 若图中有 n 个顶点，则它的生成树含有 n - 1 条边。
    2. 非连通图中：连通分量的生成树构成了非连通图的生成森林。
15. **区分极大连通子图和极小连通子图**：
    1. **极大连通子图**：是无向图的连通分量，**极大**要求该连通子图**包含所有的边**。
    2. **极小连通子图**：既要保持图连通又要使得**边数最少**的子图。
16. 生成森林：
17. 顶点的度：
    1. 入度
    2. 出度
18. 边的权和网：
    1. **网**：这种边上带权值的图称为带权图，也成为网。
19. 稠密图：
20. 稀疏图：
21. 路径：
22. 路径长度：
23. 回路：
24. 简单路径：
25. 简单回路：
26. 距离：
27. 有向树：
28. 



## 5.2 图的存储及基本操作

### 5.2.1 邻接矩阵法

1. **邻接矩阵存储**：用一个**一维数组**存储图中**顶点**的信息，用一个**二维数组**存储图中**边**的信息（即个顶点间的邻接关系），储存顶点之间邻接关系的二维数组称为**邻接矩阵**。
2. 图的邻接矩阵的**特点**：
   1. 无向图，的邻接矩阵，一定是一个**对称矩阵（并且唯一）**。
   2. 无向图，邻接矩阵的第 i 行（或第 j 列），非零元素的个数正好是顶点的度 $TD(vi)$。
   3. 有向图，
      1. 第 i **行**非零元素的个数正好是该顶点 i  的**出度** $OD(vi)$；
      2. 第 i **列**非零元素的个数正好是该顶点 i  的**入度** $ID(vi)$；
   4. **稠密图**适合用邻接矩阵存储。
   5. 

### 5.2.2 邻接表法

1. **邻接表**：
   1. 顶点表：
   2. 边表：
2. 邻接表存储的**特点**：
   1. 适用于 **稀疏图**，可以极大节省空间。
   2. 所需**存储空间**：
      1. 无向图：O(|V|+2|E|)
      2. 有向图：O(|V|+|E|)
   3. 图的邻接表表示并**不唯一**。因为，每个单链表中，各边节点的连接次序可以不同。

### 5.2.3 十字链表法

1. 是**有向图**的一种**链式存储**结构。
2. 十字链表：
   1. 顶点结点：
   2. 弧结点： 



### 5.2.4 邻接多重表

1. 只用于**无向图**。
2. 邻接多重表：
   1. 顶点结点：
   2. 边结点：
3. 邻接多重表**特点**：
   1. 比较容易判断两个顶点之间是否存在边。
   2. 与邻接表的区别：同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个节点。

## 5.3 图的遍历

### 5.3.1 广度优先搜索（BFS)

1. 类似于，二叉树的层序遍历算法。
2. BFS  的基本思想：
3. BFS  的**性能分析**：
   1. 空间复杂度：无论是邻接表还是邻接矩阵存储，BFS 都需要借助一个**辅助队列**，最坏情况需要 O(|V|)。
   2. 时间复杂度：
      1. 邻接表存储：需要 $O(|V|+|E|)$
      2. 邻接矩阵存储：$O(|V|^2)$
4. BFS 求解 单源最短路径问题： 

### 5.3.2 深度优先搜索（DFS）

1. 类似于 树的先序遍历。
2. DFS 性能分析：
   1. 空间复杂度：需要借助一个**递归工作栈**。O(|V|)
   2. 时间复杂度：
      1. 邻接表： $O(|V|+|E|)$
      2. 邻接矩阵：$O(|V|^2)$



## 5.4 图的应用

### 5.4.1 最小生成树

1. 最小生成树的**定义**：带权连通无向图中，边的权值之和最小的那棵生成树。
2. 最小生成树的**性质**：
   1. 最小生成树不唯一，即最小生成树的树形不唯一。
      1. 若图中各边权值互不相等时，生成树唯一；
      2. 若图的边数比顶点数少1，则，图的最小生成树是它本身。
   2. 最小生成树的边的权值之和总是唯一的。
   3. 最小生成树的边数 = 顶点数 - 1
3. **Prim （普里姆）算法**：
   1. 核心：点
   2. 步骤：
   3. 性能分析：
      1. 时间复杂度：$O(|V|^2)$ 
      2. 适用性：适用 **边稠密**的图。
4. **Kruskal 算法**：
   1. 核心：边
   2. 步骤：
   3. 性能分析：
      1. 时间复杂度：因为采用**堆**来存放**边的集合**。
         1. 每次选择最小权值的边：只需 $O(\log|E|)$ 
         2. 构造 T 的时间为 $O(|E| \log|E|)$ 
      2. 适用 **边稀疏而点稠密**的图。



### 5.4.2 最短路径

1. 最短路径的定义：带权路径长度最短的那条路径。
2. **Dijkstra 算法**求**单源**最短路径：
   1. 步骤：
   2. 性能分析:
      1. 时间复杂度：不论是邻接矩阵表示，还是带权的邻接表表示，都是 $O(|V|^2)$ 
   3. 适用性：**不适用**于 边上带有负权值时的图。
3. **Floyd 算法**求**各顶点之间**最短路径：
   1. 步骤：
   2. 性能分析：
      1. 时间复杂度：$O(|V|^3) $ 
   3. 适用性：
      1. Floyd 算法允许图中带有负权值的边，但是**不允许有包含带负权值的边组成的回路**。
      2. Floyd 同样适用于带权无向图。
4. **有环无向图**：
   1. 定义：若一个有向图中不存在环，则称为有向无环图，简称 **DAG 图**。

### 5.4.3 拓扑排序

1. **A0V 网**的定义：
   1. 用 DAG 图（有向无环图）表示一个工程，
   2. 其**顶点**表示**活动**，
   3. **有向边**表示活动 Vi 必须先于活动 $V_j$ 进行的这样一种**关系**，
   4. 则将这种有向图称为**顶点表示活动的网络**，记为 AOV 网。
2. 拓扑排序的**定义**：
   1. 拓扑排序定义一：（满足下面两个条件，称为图的一个拓扑排序）
      1. 每个顶点出现且只出现一次，
      2. 若顶点 A 在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到顶点 A 的路径。
   2. 拓扑排序定义二：
      1. 拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点 A 到顶点 B 的路径，则在排序中顶点 B 出现在顶点 A 的后面。
3. 拓扑排序的**性质**：
   1. 每个 AOV 网都有**一个或者多个**拓扑排序。因为一个或多个顶点的后继不唯一。
   2. 对于一般的图来说，若其**邻接矩阵是三角矩阵，则存在拓扑序列**；反之则不一定。
4. 拓扑排序的**实现**：
   1. 步骤：
      1. 从 AOV 中选一个没有前驱的顶点并输出，
      2. 从网中删除该顶点和所有以它为起点的边。
      3. 重复 1 与 2 直到当前的 AOV 网为空，或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必存在环。
   2. 性能分析：
      1. 时间复杂度：（由于输出每个顶点的同时还是删除它的边）
         1. 采用**邻接表**存储：$O(|V|+|E|)$ 
         2. 采用**邻接矩阵**存储：$O(|V|^2) $ 

### 5.4.4 关键路径

1. **AOE 网**：
   1. 在**带权有向图**中，以**顶点**表示**事件**，以**有向边**表示**活动**，以**边上的权值**表示完成该活动**开销**（如完成活动所需的时间），称之为**用边表示活动的网络**，简称 AOE 网。
   2. 
2. 关键路径的定义：从源点到汇点的所有路径中，具有**最大路径长度的路径**称为关键路径。
3. 关键活动：关键路径上的活动，称为关键活动。
4. **寻找关键活动**的参量的定义：
   1. 
5. **求关键路径的算法步骤**：
   1. 
6. 特点：
   1. 可通过加快关键活动来缩短整个工程的工期；但是，也不能任意缩短关键活动，因为一旦缩短到一定程度，就可能会变成非关键活动。
   2. 网中的关键路径**不唯一**。
   3. 且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度，并不能缩短整个工程的工期；只只有加快那些**包括在所有关键路径上的关键活动**才能达到缩短工期的目的。





# 六、查找

## 6.1 查找的基本概念



## 6.2 顺序查找、折半查找、分块查找

### 6.2.1 顺序查找



### 6.2.2 折半查找



### 6.2.3 分块查找







## 6.3 散列表

### 6.3.1 基本概念

1. **散列函数	**：
2. **冲突**：散列函数可能会把两个或者两个以上的不同关键字映射到同一地址的情况。
3. **同义词**：发生碰撞（散列函数计算出来的地址值相同）的不同关键字。
4. **散列表**：

### 6.3.2 散列函数的构造方法

1. **直接定址法**：
   1. 适合**关键字分布基本连续**的情况。
2. **除留余数法**：
   1. 公式：`H(key) = key % p`
   2. 关键在于选好 p ，尽可能减少冲突的可能性。
3. 数字分析法：
4. 平方取中法：

$$
\alpha
$$



### 6.3.3 处理冲突的方法

- 任何散列函数都**不可能绝对避免** 产生冲突。

- 分为两类：
  - 开放定址法
  - 拉链法



1. **开放定址法**：
   1. 定义：
   2. 数学递推公式：`Hi = (H(key) + di)%m`
   3. **选取增量序列**的方法有四种：
      1. 线性探测法：
         1. 会出现**堆积（聚集）**问题：大量元素在相邻的散列地址“聚集（堆积）“起来，大大降低了查找效率。
         2. 注意聚集的元素并不一定是同义词。
      2. 平方探测法：
         1. 优点：可以避免堆积问题。
         2. 缺点：不能探测到散列表上的所有单元，但至少可以探测到一半单元。
      3. **再散列法（双散列法）**：
      4. 伪随机序列法：
2. 拉链法：
   1. 定义：把所有的同义词存储在一个**线性链表**里，这个线性链表由其散列地址唯一标识。
   2. 目的：避免非同义词的发生冲突。
   3. 适用：经常经行插入和删除的情况。

### 6.3.4 散列查找及性能分析

- 散列表的查找过程与散列表的构造过程基本一致

- 平均查找长度：

  - 查找成功时：
  - 查找失败时：

- **散列表的查找效率**，取决于三个因素：

  - 散列函数
  - 处理冲突的方法：
  - 装填因子 $\alpha$：
    - 计算公式：$\alpha$ = n / m
      - n  ：表中记录数
    - m ：散列表长度
    - 注意：散列表的平均查找长度依赖于装填因子，**但是**不直接依赖于 n（表中记录数） 或者 m（散列表长度）
    - 装填因子越大，表示装的越满，则发生冲突的可能越大。
  
  





#  七、排序

## 7.1 排序的基本概念

1. **算法的稳定性**：
   1. 待排序表中两个关键字相同的元素，排序后，两个元素的先后位置不发生改变。则称这个排序算法式稳定的。
2. 内部排序算法在执行过程中都要执行两个操作：**比较和移动**。
   1. 但，基数排序就不基于比较。

## 7.2 插入排序

- 插入排序的**基本思想**：
  - 每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，知道全部记录插入完成。

### 7.2.1 直接插入排序

1. 算法步骤：

2. 直接插入排序的带**哨兵**算法：

   ```c
   // 直接插入排序-带”哨兵“算法
   void InsertSort(ElemType A[], int n){
       int i,j;
       for(i = 2;i <= n;i++){
           if (A[i] < A[i-1]){
               A[0] = A[i]; // 复制为哨兵
               for(j = i-1;A[0]<A[j];--j){
                   A[j+1] = A[j];
               }
               A[j+1] = A[0];
           }
       }
   }
   ```

3. 直接插入排序的**性能分析**：

   1. 空间效率：$O(1)$
   2. 时间效率：
      1. 最好情况：初始表已经有序的时候，只需要比较 n - 1 趟，$O(n)$。
      2. 最坏情况：初始表逆序的时候，
      3. 平均情况： $O(n^2)$
      4. 稳定性：**稳定**，因为是先比较再移动.
      5. 适用性：适用于顺序存储和链式存储的线性表。

### 7.2.2 折半插入排序

1. 适用于：排序表为顺序表（顺序存储的线性表）。

2. 基本思想：将基本插入排序的比较和移动操作分离。即，先折半查找出元素的待插入位置，然后统一的移动待插入位置的所有元素。

3. 折半插入排序的算法：

   ```c
   // 折半插入排序算法,默认顺序表，递增有序
   void InsertSort(ElemType A[], int n){
       int i,j,low,mid,high;
       for(i = 2 ;i <= n;i++){
           A[0] = A[i];
           low = 1;
           high = i -1;
           while(low <= high){
               mid = (low + high)/2;
               if (A[mid] > A[0]){
                   high = mid - 1;
               } else{
                   low = mid + 1;
               }
           }
           for(j = i - 1;j >= high + 1;--j){
               A[j+1] = A[j];
           }
           A[high+1] = A[0];
       }
   }
   ```

4. 折半插入排序的**性能分析**：

   1. 特点：
      1. 这般插入**仅减少了比较元素的次数**，约为 $O(n\log_2n)$
      2. 比较次数与初始状态无关，仅取决于表中的元素个数 n 
      3. 而元素的移动次数并没有改变，依赖于待排序表的初始状态。
   2. 时间复杂度：$O(n^2)$
   3. 稳定性：稳定。
   4. 适用于：顺序存储的线性表（顺序表），且数据量不是很大时，可以有很好的性能。



### 7.2.3 希尔排序

1. 希尔排序，又称**缩小增量排序**。

2. 基本思想：

   1. 把相隔某个”增量“的记录组成一个子表，对各个子表进行直接插入排序，当整个表中的元素已呈”基本有序“时，再对全体记录进行一次直接插入排序。

3. 希尔算法的代码：

   ```c
   // 希尔算法
   void ShellSort(ElemType A[], int n){
       for(dk = n/2;dk >= 1;dk = dk/2){ // 步长变化 dk 为步长，即增量。
           for(i = dk + 1;i <= n;++i){
               if(A[i] < A[i-dk]){
                   A[0] = A[i]; // A[0] 只是暂存单元，不是哨兵。
                   for(j = i - dk;j > 0 && A[0] < A[j];j-=dk){
                       A[j+dk] = A[j]; // 记录后移，查找插入的位置。
                   }
                    A[j+dk] = A[0];
               }
           }
       }
   }
   ```

4. 希尔算法的**性能分析**：

   1. 空间效率：$O(1)$
   2. 时间效率：
      1. 尚未确定
      2. 最坏情况：$O(n^2)$
      3. 稳定性：不稳定
      4. 适用性：仅适用于线性表为顺序存储的情况。



## 7.3 交换排序

- 交换：根据序列中两个元素关键字的比较结果来**对换**者两个记录在序列中的位置。
- 重点：快速排序。

### 7.3.1 冒泡排序

1. 冒泡排序的**基本思想**：

   1. 从后往前（或从前往后）两两比较相邻元素的值，若为逆序，则交换他们，直到序列比较完。
   2. **第一趟冒泡排序**：如上所说。结果是，将最小的元素交换到待排序列的第一个位置（或最大的到最后）
   3. 性质：
      1. 每趟冒泡排序就把最小的元素放到了序列的**最终位置**，
      2. 这样，最多执行 n -1 趟排序就可以排序完。

2. 冒泡排序的**算法代码**：

   ```c
   // 冒泡排序算法
   void BubbleSort(ElemType A[], int n){
       for(i = 0;i < n-1;i++){
           flag = false; // 表示本躺冒泡排序是否发生交换的标志
           for(j = n-1;j > i;j--){
               if(A[j-1] > A[j]){
                   swap(A[j-1],A[j]);
                   flag = true;
               }
           }
           if(flag == false){ // 本躺遍历没有发生交换，说明已经有序。
               return;
           }
       }
   }
   
   ```

3. 冒泡排序的**性能分析**：

   1. 空间效率：O(1)
   2. 时间效率：
      1. 最好情况：已经有序，比较次数为 n -1 ,移动次数 0，时间复杂度 O(n)。
      2. 最坏情况：初始逆序，比较次数 $n(n-1)/2$，移动次数 $3n(n-1)/2$,时间复杂度：$O(n^2)$
      3. 平均情况：$O(n^2)$
   3. 稳定性：稳定，因为是先比较，再交换。
   4. 性质：
      1. 每趟排序都会将一个元素放到**最终位置**。





### 7.3.2 快速排序

1. 快速排序的**基本思想**：

   1. 基于分治法，

2. 快速排序的**算法代码**：

   ```c
   // 快速排序 算法
   void QuikSort(ElemType A[], int low, int high){
       if(low < high){
           int pivotpops = Partition(A,low,high);
           QuickSort(A,low,pivotpops-1);
           QuickSort(A,pivotpops+1,high)
       }
   }
   // 划分 子表的操作
   int Partition(ElemType A[],int low,int high){
       ElemType pivot = A[low];
       while(low < high){
           while(low < high && A[high]>=pivot){ // 比枢轴小的元素，移动到左端
               --high;
           }
           A[low] = A[high];
           while(low < high && A[low] <= pivot){ // 比枢轴大的元素，移动到右端
               ++low;
           }
           A[high] = A[low];
       }
       A[low] = pivot;
       return low;
   }
   ```

3. 快速排序算法的**性能分析**：

   1. 空间效率：
      1. 需要用一个**递归工作栈**，来保存信息。
      2. 最好情况：$O(n\log_2n)$
      3. 最坏情况：$O(n)$
      4. 平均情况：$O(n\log_2n)$
   2. 时间效率：
      1. **最坏**情况：
         1. 两个区域分别包含0个和n -1个元素，即当初始排序表**基本有序或者基本逆序**的时候，就是最坏，
         2. 时间复杂度为 $O(n^2)$。
      2. 最好情况：
         1. Partition() 可能做到最平衡划分。
         2. 时间复杂度：$O(n\log_2n)$。
   3. 稳定性：不稳定。当右端区间有两个关键字相同，且均小于 pivot 时。
   4. 性质：
      1. 快速排序 是所有内部排序中**平均性能最优**的算法。
      2. 快速排序不产生有序子序列。
      3. 每趟排序会将枢轴值放到**最终位置**。

## 7.4 选择排序

- 选择排序的**基本思想**：
  - 每一趟（如第 i 趟）在后面 n-i+1 (i = 1,2,...,n-1) 个待排序元素中选取关键字最小的元素，作为有序子序列第 i 个元素，直到第 n - 1 趟做完，待排序元素就只剩一个，就不用再选了。
- 重点： 堆排序。

### 7.4.1 简单选择排序

1. 简单选择排序的基本思想：

2. 简单选择排序的**算法代码**：

   ```c
   // 简单选择排序算法
   void SelectSort(ElemType A[], int n){
       for(i = 0;i < n-1;i++){
           min = i; // 记录最小元素的位置
           for(j = i+1;j < n;j++){
               if(A[j] < A[min]){
                   min = j;
               }
           }
           if(min != j){
               swap(A[i],A[min]);
           }
       }
   }
   ```

3. 简单选择排序算法的**性能分析**：

   1. 空间效率：O(1)。
   2. 时间效率：
      1. 元素移动次数，不超过 3n(n-1)/2，最好是移动 0 次，即已经有序；
      2. 元素比较次数，与初始序列无关，都是 n(n-1)/2 次。
      3. 时间复杂度：$O(n^2)$
   3. 稳定性：**不稳定**。

### 7.4.2 堆排序

1. 堆的定义：n 个关键字序列 L[1...n] 称为堆

   1. 大根堆（大顶堆）：$L(i) >= L(2i)$ 且 $L(i) >= L(2i+1)$
   2. 小根堆（小顶堆）：$L(i) <= L(2i)$ 且$L(i) <= L(2i+1)$
   3. 上两个需要满足条件 $1 <= i <= \lfloor n/2 \rfloor$
   4. 可将该一维数组视为一个完全二叉树。

2. 堆排序需要解决的两个问题：

   1. 将无序数列构造成**初始堆**；
   2. 输出堆顶元素后，如后将剩余的元素**调整**成新的堆。

3. **构造初始大根堆**：

4. 输出栈顶元素后的**调整**。

5. **建立大根堆的算法**：

   ```c
   // 建里大根堆的算法
   void BuildMaxHeap(ElemType A[], int len){
       for(int i = len/2;i > 0;i--){
           HeadAdjust(A,i,len);
       }
       // 将元素 k 为根的字数进行调整
       void HeadAdjust(ElemType A[], int k, int len){
           A[0] = A[k];
           for(i = 2*k;i <= len;i *= 2){
               if(i < len && A[i] < A[i+1]){
                   i++;
               }
               if(A[0] >= A[i]){
                   break;
               } else{
                   A[k] = A[i];
                   k = i;
               }
           }
           A[k] = A[0];
       }
   }
   ```

6. **堆排序的算法**；

   ```c
   // 堆排序算法
   void HeadSort(ElemType A[], int len){
       BuildMaxHeap(A,len);
       for(i = len;i > 1;i--){
           Swap(A[i],A[1]);
           HeadAdjust(A,i,i-1);
       }
   }
   ```

7. 堆的插入操作：将新节点放在堆的末端，对这个新节点执行向上调整的操作。

8. 堆排序算法的**性能分析**：

   1. 空间效率：O(1)
   2. 时间效率：
      1. 建堆时间 O(n) ，之后有 n-1 次向下调整的操作，每次调整的时间为O(h)
      2. 最好，最坏，平均情况下：都是 $O(n\log_2n)$。
   3. 稳定性：**不稳定**。
   4. 适用性：适合关键字较多情况。

## 7.5 归并排序和基数排序

### 7.5.1 归并排序

1. 归并排序的**基本思想**： ”归并“的含义是将两个或两个以上的有序表组合成一个新的有序表。

2. 二路归并排序：假定待排序表有 n 个记录，可将其视为 n 个有序的子表，每个子表的长度为1 ，然后两两归并；然后继续两两归并，知道合并为一个长度 为 n 的有序表。

3. 归并排序的**算法代码**：

   ```c
   // 归并排序
   void MergeSort(ElemType A[],int low,int high){
       if(low < high){
           int mid = (low+high)/2;
           MergeSort(A,low,mid); // 对左侧子序列进行递归排序
           MergeSort(A,mid+1,high); // 对右侧子序列进行递归排序
           Merge(A,low,mid,high); // 归并
       }
   }
   // Merge() 的功能是，将两个有序的子表，归并为一个有序表
   // 表 A 的两段 A[low...mid] ,A[mid+1...high]各自有序，将它们合并成一个有序表
   ElemType *B = (ElemType *)malloc((n+1)*sizeof(ElemType)); // 辅助数组 B
   void Merge(ElemType A[], int low, int mid, int high){
       for(int k = low;k <= high;k++){ // 将 A 中所有元素复制到 B 中。
           B[k] = A[k];
       }
       for(i = low,j = mid+1,k = i;i <= mid && j <= high;k++){
           // 比较 B 中的左右两端元素，将较小值，复制到 A 中。
           if(B[i] <= B[j]){
               A[k] = B[i++];
           } else{
               A[k] = B[j++];
           }
       }
       while(i <= mid){ // 若第一个表为检测完，复制
           A[k++] = B[i++];
       }
       while(j <= high){ // 若第二个表未检测完，复制
           A[k++] = B[j++];
       }
       // 上两个 while() 函数只有一个会执行。
   }
   ```

4. 一趟归并排序的操作是：调用 $\lceil n/2h \rceil$ 次 Merge() ，将 L[1...n] 中前后相邻且长度为 h 的有序段进行两两归并。

   1. 整个归并排序需要 $\lceil \log_2n \rceil$ 趟。

5. 2路归并排序的**性能分析**:

   1. 空间效率 ：Merge() 操作中，需要 n 个辅助单元，空间复杂度为 O(n)
   2. 时间效率：每趟归并的时间复杂度为 O(n)，共需要 $\lceil \log_2n \rceil$ 趟，所以，时间复杂度为 $O(\log_2n)$。
   3. 稳定性：**稳定**。

### 7.5.2 基数排序

1. 基数排序：不急于比较和移动进行排序，而是基于**关键字各位的大小**进行排序。
2. 基数排序的作用：基数排序是一种借助关键字排序的思想对单逻辑关键字进行排序的方法。
3. 通常采用链队列：
   1. 比如：如果是都为三位数的一组数字排序，则需要借助10个链队列。
4. 基数排序的**性能分析**
   1. 空间效率：
      1. 一趟排序需要的存储空间为 r ( r 个队列)，但以后的排序会重复使用这些队列，
      2. 所以空间复杂度为 O(r)。
   2. 时间效率：
      1. 基数排序需要进行 d 趟（关键字最多有几位，比如，三位数的，就需要三趟分配和收集，一趟分配需要 O(n)，一趟收集需要 O(r)。
      2. 时间复杂度：$O(d(n+r))$
      3. 时间复杂度与**初始状态无关**。

## 7.6 内部排序算法的比较与应用

### 7.6.1 内部排序算法的比较

1. **稳定**的排序算法：
   1. 直接插入排序
   2. 冒泡排序
   3. 2路归并排序
   4. 基数排序
2. **不稳定**的排序算法：
   1. 简单选择排序
   2. 希尔排序
   3. 快速排序
   4. 堆排序
3. **空间复杂度不为 $O(1)$**的
   1. 快速排序：$O(\log_2n)$
   2. 2路归并排序：$O(n)$
   3. 基数排序：$O(r)$
4. 每一趟排序可以确定一个元素的**最终位置**的排序：
   1. 冒泡排序
   2. 快速排序



### ==内部排序总结表格==

|   算法种类   |                |   时间复杂度   |                |  空间复杂度  | 是否稳定 |   算法种类   |
| :----------: | :------------: | :------------: | :------------: | :----------: | :------: | :----------: |
|              |    最好情况    |    平均情况    |    最坏情况    |              |          |              |
| 直接插入排序 |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$    |    是    | 直接插入排序 |
|   冒泡排序   |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$    |    是    |   冒泡排序   |
| 简单选择排序 |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$    |    否    | 简单选择排序 |
|   希尔排序   |                |                |                |    $O(1)$    |    否    |   希尔排序   |
|   快速排序   | $O(n \log_2n)$ | $O(n \log_2n)$ |    $O(n^2)$    | $O(\log_2n)$ |    否    |   快速排序   |
|    堆排序    | $O(n \log_2n)$ | $O(n \log_2n)$ | $O(n \log_2n)$ |    $O(1)$    |    否    |    堆排序    |
| 2 路归并排序 | $O(n \log_2n)$ | $O(n \log_2n)$ | $O(n \log_2n)$ |    $O(n)$    |    是    | 2 路归并排序 |
|   基数排序   |  $O(d(n+r))$   |  $O(d(n+r))$   |  $O(d(n+r))$   |    $O(r)$    |    是    |   基数排序   |



### 7.6.2 内部排序算法的应用 

1. 当文件的初始状态已经**基本有序**时：选择**直接插入排序**或者**冒泡排序**。
2. 若 n 较小 ，可采用 **直接插入排序**或**简单选择排序**；
   1. 又当记录本身信息量较大时，用**简单选择排序**。
3. 若 n 较大，则应采用时间复杂度为 $O(n \log_2n)$ 的排序算法：快速排序，堆排序，归并排序。
   1. **快速排序**：当关键字随机分布时，平均时间最短。不稳定
   2. **堆排序**：所需的辅助空间少于快速排序，并不会出现快速排序的极端情况（基本有序，而时间耗费最多）。不稳定。
   3. **归并排序**：若要求排序算法稳定，且时间复杂度为 $O(n \log_2n)$ ，则用归并排序。稳定。
4. 当文件的 n 个关键字随机分布时，任何借助于”比较”的排序算法，至少需要  $O(n \log_2n)$ 的时间。
5. 若 n 很大，记录的关键字位数较少且可以分解时，采用**基数排序**。
6. 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用**链表**作为存储结构。



# 八、820 真题总结

数据结构：

1. **题型分布**：
   1. 填空题：10分（5个题，10个空）
   2. 选择题：20分（10个）
   3. 简答题：30分（6道）
   4. 算法题：15分（2道）
2. **算法题**的内容：
   1. 第一题：一般是**数组**或者**单循环链表**
   2. 第二题：一般是**二叉链表**存储的**二叉树**。







# THE END

